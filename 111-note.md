이전 챌린지에서 재귀를 사용하여 for 루프를 대체하는 방법을 배웠습니다. 이제 1부터 시작하여 함수에 전달 된 숫자까지 연속적인 정수 배열을 반환하는 더 복잡한 함수를 살펴 보겠습니다.

이전 과제에서 언급했듯이 기본 사례가 있습니다. 기본 케이스는 더 이상 자신을 호출 할 필요가 없을 때 재귀 함수에 알려줍니다. 반환 값이 이미 알려진 간단한 경우입니다. 다른 인수로 원래 함수를 실행하는 재귀 호출도 있습니다. 함수가 올바르게 작성되면 결국 기본 케이스에 도달합니다.

예를 들어 1부터 n까지의 숫자를 포함하는 배열을 반환하는 재귀 함수를 작성한다고 가정 해 보겠습니다. 이 함수는 최종 숫자를 나타내는 인수 n을 받아야합니다. 그런 다음 1에 도달 할 때까지 점차적으로 더 작은 n 값으로 자신을 호출해야합니다. 다음과 같이 함수를 작성할 수 있습니다.

function countup (n) {
  if (n <1) {
    반환 [];
  } else {
    const countArray = countup (n-1);
    countArray.push (n);
    return countArray;
  }
}
console.log (countup (5)); // [1, 2, 3, 4, 5]
처음에는 n의 값이 감소하기 때문에 직관적이지 않은 것처럼 보이지만 최종 배열의 값은 증가합니다. 이는 재귀 호출이 반환 된 후 푸시가 마지막에 발생하기 때문에 발생합니다. n이 배열로 푸시되는 지점에서 countup (n-1)은 이미 평가되어 [1, 2, ..., n-1]을 반환합니다.